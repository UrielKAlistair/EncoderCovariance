#include <ros/ros.h>
#include <nav_msgs/Odometry.h>
#include "Eigen/Dense"

using namespace std;
/*
 * Inputs:
 * Distance travelled by each wheel for every instant
 * Theta of the vehicle orientation as generated by a vehicle model.
 *
 * Outputs:
 * Covariance matrix of position of robot.(Really, packaged back with the rest of the odom?)
 *
 */
// This code takes in Encoder data to publish a covariance matrix, giving the error distribution for the position of the vehicle.

// Defining Vehicle constants
// variance of left wheel measurements, sigma**2 = kl |dl| Similar thing for right wheel.
// note that the paper uses kl**2 wherever I use kl
double kl = 10;
double kr = 10;
double B; // This is the wheel base distance.

Eigen::MatrixXd S0(3, 3);
// This is the matrix representing the covariance of the "zero state" of the robot.
// It is global because the S0 is updated in the main function every time the radius of curvature changes and utilised
// by our publisher function to generate the final covariance

Eigen::MatrixXd mycovar(3, 3);
//this is a 3 by 3 covar matrix that gets updated every time we publish the covariance.
// It is here because we need it inside main as well, to update S0.

boost::array<double, 36> covar;

// this is a 6 by 6 matrix, a ros default message type. In order, it is x,y,z angle about x, angle about y, angle about z.
// for us, z is certain, and so is theta about x and y.
// In the main function, I set entries 12 to 30 to zero to account for this.
// I keep it global to avoid having to repeatedly generate this matrix.

Eigen::MatrixXd A(3, 3);
// Final Covariance matrix is U + A(S0)A' U is defined inside the publish function, wheras S0 is a global thing.
// A changes with radius of curvature and thus needs to be kept global for updates in main and usage in the function.

void publishcovariance(double L, double R, double r, double thetak, double theta0, const ros::Publisher &cov_pos_pub) {

    //Defining constants for calculations
    double c1 = kr * abs(R) * L + kl * abs(L) * R;
    double c2 = kr * abs(R) + kl * abs(L);
    double c3 = kr * pow(L, 2) * abs(R) + kl * pow(R, 2) * abs(L);

    //Defining matrix U

    Eigen::MatrixXd U(3, 3);
    if (r != -1) {

        double lr2 = pow((L - R), 2), lr3 = pow((L - R), 3);
        double coeff1 = 2 * r * c1 / lr2;
        double coeff2 = r * c2 / pow(B, 2;


        U(0, 0) = -coeff1 * (sin(theta0) - sin(thetak)) * cos(thetak) +
                  pow((r * cos(thetak) / B), 2) * c2 - (B * c3 / 4 * lr3) *
                                                       (2 * (thetak - theta0) * sin(thetak) - sin(2 * theta0) +
                                                        sin(2 * thetak));
        U(1, 1) = -coeff1 * (cos(thetak) - cos(theta0)) * sin(thetak) +
                  pow((r * sin(thetak) / B), 2) * c2 - (B * c3 / 4 * lr3) *
                                                       (2 * (thetak - theta0) * sin(thetak) + sin(2 * theta0) -
                                                        sin(2 * thetak));
        U(2, 2) = c2 / pow(B, 2);
        U(0, 1) = -(coeff1 / 2) * (cos(2 * thetak) - cos(thetak + theta0)) +
                  (c2 / 2) * pow((r / B), 2) * sin(2 * thetak)
                  - (B * c3 / 4 * lr3) * (cos(2 * theta0) - cos(2 * thetak));
        U(1, 0) = U(0, 1);
        U(0, 2) = (c1 / lr2) * (sin(theta0) - sin(thetak)) - coeff2 * cos(thetak);
        U(2, 0) = U(0, 2);
        U(1, 2) = (c1 / lr2) * (cos(thetak) - cos(theta0)) - coeff2 * sin(thetak);
        U(2, 1) = U(1, 2);

    } else {
        double ksdiff = pow(kl, 2) - pow(kr, 2);
        double kssum = pow(kl, 2) + pow(kr, 2);

        U(0, 0) = abs(L) * ((pow(cos(thetak), 2) / 4) * kssum +
                            (L / (2 * B)) * sin(thetak) * cos(thetak) * ksdiff +
                            (pow(L, 2) / (3 * pow(B, 2))) * pow(sin(thetak), 2) * kssum;
        U(1, 1) = U(0, 0) - (L / (B)) * sin(thetak) * cos(thetak) * ksdiff;
        U(2, 2) = (abs(L) / pow(B, 2)) * kssum;
        U(0, 1) = abs(L) * (((1.0 / 8) - pow(L, 2) / (6 * pow(B, 2))) * sin(2 * thetak) * kssum +
                            L * cos(2 * thetak) * (pow(kr, 2) - pow(kl, 2) / (4 * B)));
        U(1, 0) = U(0, 1);
        U(1, 2) = abs(L) * (cos(thetak) * (pow(kr, 2) - pow(kl, 2) / 2 * B) -
                            L * sin(thetak) * (pow(kr, 2) + pow(kl, 2) / (2 * pow(B, 2))));
        U(2, 1) = U(1, 2);
        U(2, 1) = abs(L) * ((thetak) * (pow(kr, 2) - pow(kl, 2) / 2 * B) -
                            L * cos(thetak) * (pow(kr, 2) + pow(kl, 2) / (2 * pow(B, 2))));
        U(1, 2) = U(2, 1);
    }

    mycovar = U + A * S0 * A.transpose();

    for (int i = 0; i < 3; i++) {
        covar[i] = mycovar(0, i);
        covar[i + 6] = mycovar(1, i);
        covar[i + 30] = mycovar(2, i);
    }

    nav_msgs::Odometry odom;
    odom.header.stamp = ros::Time::now();
    odom.header.frame_id = "odom";

    //set the position
    odom.pose.pose.position.x = x;
    odom.pose.pose.position.y = y;
    odom.pose.pose.position.z = 0.0;
    odom.pose.pose.orientation = odom_quat;

    //set the velocity
    odom.child_frame_id = "base_link";
    odom.twist.twist.linear.x = vx;
    odom.twist.twist.linear.y = vy;
    odom.twist.twist.angular.z = vth;

    //set the pose covariance
    odom.pose.covariance = covar;
    cov_pos_pub.publish(odom);
}

int main(int argc, char **argv) {

    // initialising ROS

    ros::init(argc, argv, "talker");

    ros::NodeHandle n;
    ros::Publisher cov_pos_pub = n.advertise<nav_msgs::Odometry>("odom_topic", 10);
    //ros::Subscriber sub = n.subscribe("pose", 10, Callback);

    for (int i = 12; i < 30; i++) {
        covar[i] = 0;
    }

    double theta0 = 0; //the initial orientation of the vehicle is set to be 0
    double Lk;
    double Rk;
    // These two are the distances travelled in the kth instant of time. We will get this from the encoder.
    double rold;

    if (Lk != Rk) {
        rold = (B * (Lk + Rk)) / ((Lk - Rk) * 2); // initial radius of curvature
    } else {
        rold = -1; // Have to handle straight line case separately
    }

    double r = rold;

    double L = 0;  // This is the distance travelled by the left wheel from S0.
    double R = 0;  // Right wheel
    double thetak; // fetch final vehicle angle from somewhere

    A(0, 0) = 1;
    A(1, 0) = 0;
    A(2, 0) = 0;
    A(0, 1) = 0;
    A(2, 1) = 1;
    A(2, 1) = 0;
    A(2, 2) = 1;
    A(0, 2) = r * (cos(theta0) - cos(thetak));
    A(1, 2) = r * (sin(theta0) - sin(thetak));

    while (ros::ok()) {
        // while the radius of curvature is constant, keep accumulating distance; use a fixed formula.
        // Once r changes, we will set the existing State as S0, and use Covariance of this to redefine the V matrix

        while (r == rold) {

            L += Lk;
            R += Rk;
            publishcovariance(L, R, r, thetak, theta0, cov_pos_pub);
            //    ros::spinOnce();                       // fetch new Lk,Rk, theta

            if (Lk != Rk) {
                r = (B * (Lk + Rk)) / ((Lk - Rk) * 2); // initial radius of curvature
            } else {
                r = -1; // straight line case separately
            }
        }

        theta0 = thetak; // fetch it
        L = Lk;
        R = Rk;
        rold = r;
        A(0, 2) = r * (cos(theta0) - cos(thetak));
        A(1, 2) = r * (sin(theta0) - sin(thetak));
        S0 = mycovar;
    }
}
// TODO :
//  Set up fakeencoder for Left and Right wheels
//  Ensure you can subscribe to it and get data.
//  Publish the Covariance and check if it seems legit